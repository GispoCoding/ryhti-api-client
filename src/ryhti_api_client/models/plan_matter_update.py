# coding: utf-8

"""
Ryhti API

Rakennetun ympäristön tietojärjestelmän rajapinta

The version of the OpenAPI document: 1
Generated by OpenAPI Generator (https://openapi-generator.tech)

Do not edit the class manually.
"""  # noqa: E501

from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from datetime import date
from pydantic import BaseModel, ConfigDict, Field, StrictStr, field_validator
from typing import Any, ClassVar, Dict, List, Optional
from typing_extensions import Annotated
from ryhti_api_client.models.language_string import LanguageString
from ryhti_api_client.models.participation_and_assessment_scheme import (
    ParticipationAndAssessmentScheme,
)
from ryhti_api_client.models.plan_attachment_document import PlanAttachmentDocument
from ryhti_api_client.models.plan_operator import PlanOperator
from ryhti_api_client.models.plan_source_data import PlanSourceData
from typing import Set
from typing_extensions import Self


class PlanMatterUpdate(BaseModel):
    """
    PlanMatterUpdate
    """  # noqa: E501

    permanent_plan_identifier: Annotated[str, Field(min_length=1, strict=True)] = Field(
        description="pysyväKaavaTunnus Esim AK-00001", alias="permanentPlanIdentifier"
    )
    plan_type: StrictStr = Field(
        description='Kaavan tyyppi. Käytetään koodistoa <a href="http://uri.suomi.fi/codelist/rytj/RY_Kaavalaji">http://uri.suomi.fi/codelist/rytj/RY_Kaavalaji</a>',
        alias="planType",
    )
    name: LanguageString = Field(
        description="Lokalisoitu merkkijono-luokka eri kielille. Lisää vähintään yksi kieli."
    )
    time_of_initiation: date = Field(
        description="vireilletulopäivämäärä", alias="timeOfInitiation"
    )
    description: Optional[LanguageString] = Field(
        default=None,
        description="Lokalisoitu merkkijono-luokka eri kielille. Lisää vähintään yksi kieli.",
    )
    producer_plan_identifier: Optional[StrictStr] = Field(
        default=None,
        description="kunnan tai maakunnan tuottajakohtainen kaavatunnus",
        alias="producerPlanIdentifier",
    )
    case_identifiers: Optional[List[StrictStr]] = Field(
        default=None, description="asianhallintatunnukset", alias="caseIdentifiers"
    )
    related_binding_plot_division_matter_uri: Optional[StrictStr] = Field(
        default=None,
        description="Deprecated, use relatedBindingPlotDivisionMatterUris",
        alias="relatedBindingPlotDivisionMatterUri",
    )
    related_binding_plot_division_matter_uris: Optional[List[StrictStr]] = Field(
        default=None,
        description="Liittyvät pysyvät tonttijakoasiat (URI)",
        alias="relatedBindingPlotDivisionMatterUris",
    )
    record_numbers: Optional[List[StrictStr]] = Field(
        default=None, description="diaarinumerot", alias="recordNumbers"
    )
    administrative_area_identifiers: List[StrictStr] = Field(
        description="Hallinnollisen alueen tunnus. Kuntatunnus tai maakuntatunnus.",
        alias="administrativeAreaIdentifiers",
    )
    digital_origin: StrictStr = Field(
        description='Tieto kaavan digitaalisen muodon tuotantotavasta ja siihen liittyvästä juridisuuden asteesta. Käytetään koodistoa <a href="http://uri.suomi.fi/codelist/rytj/RY_DigitaalinenAlkupera">http://uri.suomi.fi/codelist/rytj/RY_DigitaalinenAlkupera</a>',
        alias="digitalOrigin",
    )
    matter_annexes: Optional[List[PlanAttachmentDocument]] = Field(
        default=None,
        description="Asian kuvaamiseen tai käsittelyyn olennaisesti kuuluva liitetty asiakirja.",
        alias="matterAnnexes",
    )
    responsible_party: Optional[PlanOperator] = Field(
        default=None, description="Vastuutaho", alias="responsibleParty"
    )
    participation_and_assessment_scheme: Optional[ParticipationAndAssessmentScheme] = (
        Field(
            default=None,
            description="Osallistumis- ja arviointisuunnitelma",
            alias="participationAndAssessmentScheme",
        )
    )
    source_datas: Optional[List[PlanSourceData]] = Field(
        default=None, description="Lähtötietoaineisto", alias="sourceDatas"
    )
    related_plan_matters: Optional[List[StrictStr]] = Field(
        default=None,
        description="Liittyvät kaava asiat (URI)",
        alias="relatedPlanMatters",
    )
    __properties: ClassVar[List[str]] = [
        "permanentPlanIdentifier",
        "planType",
        "name",
        "timeOfInitiation",
        "description",
        "producerPlanIdentifier",
        "caseIdentifiers",
        "relatedBindingPlotDivisionMatterUri",
        "relatedBindingPlotDivisionMatterUris",
        "recordNumbers",
        "administrativeAreaIdentifiers",
        "digitalOrigin",
        "matterAnnexes",
        "responsibleParty",
        "participationAndAssessmentScheme",
        "sourceDatas",
        "relatedPlanMatters",
    ]

    @field_validator("plan_type")
    def plan_type_validate_enum(cls, value):
        """Validates the enum"""
        if value not in set(
            [
                "http://uri.suomi.fi/codelist/rytj/RY_Kaavalaji/code/1",
                "http://uri.suomi.fi/codelist/rytj/RY_Kaavalaji/code/2",
                "http://uri.suomi.fi/codelist/rytj/RY_Kaavalaji/code/3",
                "http://uri.suomi.fi/codelist/rytj/RY_Kaavalaji/code/11",
                "http://uri.suomi.fi/codelist/rytj/RY_Kaavalaji/code/12",
                "http://uri.suomi.fi/codelist/rytj/RY_Kaavalaji/code/21",
                "http://uri.suomi.fi/codelist/rytj/RY_Kaavalaji/code/22",
                "http://uri.suomi.fi/codelist/rytj/RY_Kaavalaji/code/23",
                "http://uri.suomi.fi/codelist/rytj/RY_Kaavalaji/code/24",
                "http://uri.suomi.fi/codelist/rytj/RY_Kaavalaji/code/25",
                "http://uri.suomi.fi/codelist/rytj/RY_Kaavalaji/code/31",
                "http://uri.suomi.fi/codelist/rytj/RY_Kaavalaji/code/32",
                "http://uri.suomi.fi/codelist/rytj/RY_Kaavalaji/code/33",
                "http://uri.suomi.fi/codelist/rytj/RY_Kaavalaji/code/34",
                "http://uri.suomi.fi/codelist/rytj/RY_Kaavalaji/code/35",
                "http://uri.suomi.fi/codelist/rytj/RY_Kaavalaji/code/39",
            ]
        ):
            raise ValueError(
                "must be one of enum values ('http://uri.suomi.fi/codelist/rytj/RY_Kaavalaji/code/1', 'http://uri.suomi.fi/codelist/rytj/RY_Kaavalaji/code/2', 'http://uri.suomi.fi/codelist/rytj/RY_Kaavalaji/code/3', 'http://uri.suomi.fi/codelist/rytj/RY_Kaavalaji/code/11', 'http://uri.suomi.fi/codelist/rytj/RY_Kaavalaji/code/12', 'http://uri.suomi.fi/codelist/rytj/RY_Kaavalaji/code/21', 'http://uri.suomi.fi/codelist/rytj/RY_Kaavalaji/code/22', 'http://uri.suomi.fi/codelist/rytj/RY_Kaavalaji/code/23', 'http://uri.suomi.fi/codelist/rytj/RY_Kaavalaji/code/24', 'http://uri.suomi.fi/codelist/rytj/RY_Kaavalaji/code/25', 'http://uri.suomi.fi/codelist/rytj/RY_Kaavalaji/code/31', 'http://uri.suomi.fi/codelist/rytj/RY_Kaavalaji/code/32', 'http://uri.suomi.fi/codelist/rytj/RY_Kaavalaji/code/33', 'http://uri.suomi.fi/codelist/rytj/RY_Kaavalaji/code/34', 'http://uri.suomi.fi/codelist/rytj/RY_Kaavalaji/code/35', 'http://uri.suomi.fi/codelist/rytj/RY_Kaavalaji/code/39')"
            )
        return value

    @field_validator("digital_origin")
    def digital_origin_validate_enum(cls, value):
        """Validates the enum"""
        if value not in set(
            [
                "http://uri.suomi.fi/codelist/rytj/RY_DigitaalinenAlkupera/code/01",
                "http://uri.suomi.fi/codelist/rytj/RY_DigitaalinenAlkupera/code/02",
                "http://uri.suomi.fi/codelist/rytj/RY_DigitaalinenAlkupera/code/03",
                "http://uri.suomi.fi/codelist/rytj/RY_DigitaalinenAlkupera/code/04",
                "http://uri.suomi.fi/codelist/rytj/RY_DigitaalinenAlkupera/code/0401",
            ]
        ):
            raise ValueError(
                "must be one of enum values ('http://uri.suomi.fi/codelist/rytj/RY_DigitaalinenAlkupera/code/01', 'http://uri.suomi.fi/codelist/rytj/RY_DigitaalinenAlkupera/code/02', 'http://uri.suomi.fi/codelist/rytj/RY_DigitaalinenAlkupera/code/03', 'http://uri.suomi.fi/codelist/rytj/RY_DigitaalinenAlkupera/code/04', 'http://uri.suomi.fi/codelist/rytj/RY_DigitaalinenAlkupera/code/0401')"
            )
        return value

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )

    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of PlanMatterUpdate from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of name
        if self.name:
            _dict["name"] = self.name.to_dict()
        # override the default output from pydantic by calling `to_dict()` of description
        if self.description:
            _dict["description"] = self.description.to_dict()
        # override the default output from pydantic by calling `to_dict()` of each item in matter_annexes (list)
        _items = []
        if self.matter_annexes:
            for _item_matter_annexes in self.matter_annexes:
                if _item_matter_annexes:
                    _items.append(_item_matter_annexes.to_dict())
            _dict["matterAnnexes"] = _items
        # override the default output from pydantic by calling `to_dict()` of responsible_party
        if self.responsible_party:
            _dict["responsibleParty"] = self.responsible_party.to_dict()
        # override the default output from pydantic by calling `to_dict()` of participation_and_assessment_scheme
        if self.participation_and_assessment_scheme:
            _dict["participationAndAssessmentScheme"] = (
                self.participation_and_assessment_scheme.to_dict()
            )
        # override the default output from pydantic by calling `to_dict()` of each item in source_datas (list)
        _items = []
        if self.source_datas:
            for _item_source_datas in self.source_datas:
                if _item_source_datas:
                    _items.append(_item_source_datas.to_dict())
            _dict["sourceDatas"] = _items
        # set to None if description (nullable) is None
        # and model_fields_set contains the field
        if self.description is None and "description" in self.model_fields_set:
            _dict["description"] = None

        # set to None if producer_plan_identifier (nullable) is None
        # and model_fields_set contains the field
        if (
            self.producer_plan_identifier is None
            and "producer_plan_identifier" in self.model_fields_set
        ):
            _dict["producerPlanIdentifier"] = None

        # set to None if case_identifiers (nullable) is None
        # and model_fields_set contains the field
        if (
            self.case_identifiers is None
            and "case_identifiers" in self.model_fields_set
        ):
            _dict["caseIdentifiers"] = None

        # set to None if related_binding_plot_division_matter_uri (nullable) is None
        # and model_fields_set contains the field
        if (
            self.related_binding_plot_division_matter_uri is None
            and "related_binding_plot_division_matter_uri" in self.model_fields_set
        ):
            _dict["relatedBindingPlotDivisionMatterUri"] = None

        # set to None if related_binding_plot_division_matter_uris (nullable) is None
        # and model_fields_set contains the field
        if (
            self.related_binding_plot_division_matter_uris is None
            and "related_binding_plot_division_matter_uris" in self.model_fields_set
        ):
            _dict["relatedBindingPlotDivisionMatterUris"] = None

        # set to None if record_numbers (nullable) is None
        # and model_fields_set contains the field
        if self.record_numbers is None and "record_numbers" in self.model_fields_set:
            _dict["recordNumbers"] = None

        # set to None if matter_annexes (nullable) is None
        # and model_fields_set contains the field
        if self.matter_annexes is None and "matter_annexes" in self.model_fields_set:
            _dict["matterAnnexes"] = None

        # set to None if responsible_party (nullable) is None
        # and model_fields_set contains the field
        if (
            self.responsible_party is None
            and "responsible_party" in self.model_fields_set
        ):
            _dict["responsibleParty"] = None

        # set to None if participation_and_assessment_scheme (nullable) is None
        # and model_fields_set contains the field
        if (
            self.participation_and_assessment_scheme is None
            and "participation_and_assessment_scheme" in self.model_fields_set
        ):
            _dict["participationAndAssessmentScheme"] = None

        # set to None if source_datas (nullable) is None
        # and model_fields_set contains the field
        if self.source_datas is None and "source_datas" in self.model_fields_set:
            _dict["sourceDatas"] = None

        # set to None if related_plan_matters (nullable) is None
        # and model_fields_set contains the field
        if (
            self.related_plan_matters is None
            and "related_plan_matters" in self.model_fields_set
        ):
            _dict["relatedPlanMatters"] = None

        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of PlanMatterUpdate from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate(
            {
                "permanentPlanIdentifier": obj.get("permanentPlanIdentifier"),
                "planType": obj.get("planType"),
                "name": LanguageString.from_dict(obj["name"])
                if obj.get("name") is not None
                else None,
                "timeOfInitiation": obj.get("timeOfInitiation"),
                "description": LanguageString.from_dict(obj["description"])
                if obj.get("description") is not None
                else None,
                "producerPlanIdentifier": obj.get("producerPlanIdentifier"),
                "caseIdentifiers": obj.get("caseIdentifiers"),
                "relatedBindingPlotDivisionMatterUri": obj.get(
                    "relatedBindingPlotDivisionMatterUri"
                ),
                "relatedBindingPlotDivisionMatterUris": obj.get(
                    "relatedBindingPlotDivisionMatterUris"
                ),
                "recordNumbers": obj.get("recordNumbers"),
                "administrativeAreaIdentifiers": obj.get(
                    "administrativeAreaIdentifiers"
                ),
                "digitalOrigin": obj.get("digitalOrigin"),
                "matterAnnexes": [
                    PlanAttachmentDocument.from_dict(_item)
                    for _item in obj["matterAnnexes"]
                ]
                if obj.get("matterAnnexes") is not None
                else None,
                "responsibleParty": PlanOperator.from_dict(obj["responsibleParty"])
                if obj.get("responsibleParty") is not None
                else None,
                "participationAndAssessmentScheme": ParticipationAndAssessmentScheme.from_dict(
                    obj["participationAndAssessmentScheme"]
                )
                if obj.get("participationAndAssessmentScheme") is not None
                else None,
                "sourceDatas": [
                    PlanSourceData.from_dict(_item) for _item in obj["sourceDatas"]
                ]
                if obj.get("sourceDatas") is not None
                else None,
                "relatedPlanMatters": obj.get("relatedPlanMatters"),
            }
        )
        return _obj
